/**
 * Copyright 2013 Eduard Huguet Cuadrench
 * 
 * This file is part of JSMapper kernel module.
 * 
 * JSMapper is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2.1 of the License.
 * 
 * Foobar is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with JSMapper.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * \file jsmapper_api.h
 * \brief JSMapper kernel module public API
 * \author Eduard Huguet <eduardhc@gmail.com>
 */

#ifndef __JSMAPPER_API_H_
#define __JSMAPPER_API_H_

#include <linux/ioctl.h>
#include <linux/types.h>


/*************************************************************************************************************
 * 
 * Definitions:
 * 
 *************************************************************************************************************/

/** Current API version */
#define JSMAPPER_API_VERSION			0x010000	/* 1.0.0 */



/*************************************************************************************************************
 * 
 * Action types
 * 
 *************************************************************************************************************/

/** 
 * Non-overrided element. This means that the axis / button will behave as the parent mode defines (in case of nested modes), 
 * or else it will behave the default way (original button event will be untouched)
 */
#define JSMAPPER_ACTION_DEFAULT		-1

/** 
 * No key event will be generated by this element. Depending on the 'filter' value, the original event 
 * will make its way to the joystick event handler, or else it will be simply filtered out
 */
#define JSMAPPER_ACTION_NONE		0

/** 
 * The element will issue a key stroke. Depending on the 'single' flag in key structure, key will be hold down 
 * as long as button is pressed, or either it will be immediately released. BTN_LEFT, MIDDLE & RIGHT codes are 
 * also supported, so this action can be used to generate mouse clicks.
 */ 
#define JSMAPPER_ACTION_KEY			1

/**
  * The element will issue a sequence of consecutive press / release events when activated. This is, it will play 
  * a "macro"-like key sequence, which will allows user to automate a serie of steps.
  */
#define JSMAPPER_ACTION_MACRO       2

/** 
 * The element will issue steps for a relative axis.
 */ 
#define JSMAPPER_ACTION_REL			3


/*************************************************************************************************************
 * 
 * Mode trigger types:
 * 
 *************************************************************************************************************/

/**
  No specific condition (used only by root mode)
  */
#define JSMAPPER_MODE_CONDITION_NONE          0

/**
  Button-based condition: if trigger button is in pressed state, then mode will be active
  */
#define JSMAPPER_MODE_CONDITION_BUTTON        1

/**
  Axis-based condition: if current axis value is inside defined range, then mode will be active
  */
#define JSMAPPER_MODE_CONDITION_AXIS          2


/*************************************************************************************************************
 * 
 * Keystroke modifiers:
 * 
 *************************************************************************************************************/

#define JSMAPPER_MODIFIER_CTRL_L            1
#define JSMAPPER_MODIFIER_CTRL_R            2
#define JSMAPPER_MODIFIER_CTRL              JSMAPPER_MODIFIER_CTRL_L

#define JSMAPPER_MODIFIER_SHIFT_L           4
#define JSMAPPER_MODIFIER_SHIFT_R           8
#define JSMAPPER_MODIFIER_SHIFT             JSMAPPER_MODIFIER_SHIFT_L

#define JSMAPPER_MODIFIER_ALT_L             16
#define JSMAPPER_MODIFIER_ALT_R             32
#define JSMAPPER_MODIFIER_ALT               JSMAPPER_MODIFIER_ALT_L

#define JSMAPPER_MODIFIER_META_L            64
#define JSMAPPER_MODIFIER_META_R            128
#define JSMAPPER_MODIFIER_META              JSMAPPER_MODIFIER_META_L


/*************************************************************************************************************
 * 
 * Parameter structures
 * 
 *************************************************************************************************************/

/**
 * \brief Assignment struct representing a keyboard, or mouse button, event
 */

struct t_JSMAPPER_KEY 
{
	/** A key code, as defined in linux/input.h header file */
	__u16 id;
	/** A modifier mask, as defined in this API header file */
	__u16 modifiers;
    /** If 0, key will be hold down as long as button is pressed. Else, it will be immediately released */
    __u16 single;
};


/**
 * \brief Assignment struct representing a relative axis movement
 *
 * Assignment struct representing a relative axis movement.
 */

struct t_JSMAPPER_REL
{
	/** A relative axis ID (REL_xxx, usually REL_X or REL_Y */
	__u16 id;
    /** If 0, axis movement will be repeated until button is released. If 1, a single step will be sent */
    __u16 single;
	/** Number of axis units to move per step*/
	__s16 step;
    /** Time spacing between steps, in ms (only for single=0) */
    __u16  spacing;
};


/**
 * \brief Assignment struct representing a macro event
 */

struct t_JSMAPPER_MACRO 
{
    /** Time spacing between keys, in ms */
    __u16  spacing;
    /** Number of keys contained in array */
    __u16  count;
    /** Variable-size array containing the key sequence to issue. The 'single' flag is ignored for macros */
    struct t_JSMAPPER_KEY keys[0];
};


/**
  * \brief Mode structure
  * This structure is used to add / remove modes from the device.
  */

struct t_JSMAPPER_MODE 
{
	/** Mode identifier */
	__u16 mode_id;
    /** Parent mode identifier (0 for root) */
	__u16 parent_mode_id;
    /** Conditiontype (NONE for root)*/
    __u16 condition_type;
    /** Variable union struct condition data */
    union 
    {
		/** Button definition - used by JMIOCSBUTTONACTION API */
		struct
		{
			__u16 id;
		} button;

		/** Axis & band definition - used by JMIOCSAXISACTION API */
		struct
		{
			__u16 id;
			__s32 low;
			__s32 high;
		} axis;
    } condition;
};


/**
 * \brief Core button / axis action
 *
 * This structure is used to define the action for both a given button or an axis band. It's variable-sized, 
 * since key sequence action can contain an arbitrary number of keys.
 */

struct t_JSMAPPER_ACTION
{
	/** Mode ID this action refers to */
	__u16 mode_id;

	union
	{
		/** Button definition - used by JMIOCSBUTTONACTION API */
		struct
		{
			__u16 id;
		} button;

		/** Axis & band definition - used by JMIOCSAXISACTION API */
		struct
		{
			__u16 id;
			__s32 low;
			__s32 high;
		} axis;
	};

	/** Action type - see JSMAPPER_ACTION_xxx constants */
	__s16 type;

    /** If true, button event will be filtered out. Else, it will make its way to the joystick driver */
	__u8 filter;
    
	/** Variable union struct containing action data */
	union
	{
		/** action struct used for 'key' action type */
		struct t_JSMAPPER_KEY key;
        /** action struct used for 'macro' action type */
        struct t_JSMAPPER_MACRO macro;
        /** action struct used for 'rel' action type */
        struct t_JSMAPPER_REL rel;
	} data;
};



/*************************************************************************************************************
  
 IOCTL codes:
 
	They are defined using the same 'magic' number as joystick driver ('j'), right after the range assigned 
 to joydev.c (0x00-0x3f) in Documentation/ioctl/ioctl-numbers.txt.
 
*************************************************************************************************************/

/*
    Query codes:
*/

/**
  \brief Returns current API version
  */
#define JMIOCGVERSION					_IOR('j', 0x40, __u32)

/**
  \brief Returns mapped device's name
  \param len Size of buffer provided, in bytes
  */
#define JMIOCGNAME(len)					_IOC(_IOC_READ, 'j', 0x41, len)

/**
  \brief Returns mapped device's number of axes
  */
#define JMIOCGAXES						_IOR('j', 0x42, __u8)

/**
  \brief Returns mapped device's number of buttons
  */
#define JMIOCGBUTTONS					_IOR('j', 0x43, __u8)

/**
  \brief Returns mapped device's current button value
  */
#define JMIOCGBUTTONVALUE				_IOWR('j', 0x44, __s32)

/**
  \brief Returns mapped device's current axis value
  */
#define JMIOCGAXISVALUE					_IOWR('j', 0x45, __s32)



/*
    Programming codes:
*/

/**
  \brief Clears all button & axes actions, modes, etc...
  */
#define JMIOCCLEAR						_IO('j', 0x50 )

/**
  \brief Sets the provided action to the given button
  
  This function should be called by passing it a pointer to a t_JSMAPPER_ACTION structure, appropiately 
  sized to the action type specified.
  */
#define JMIOCSBUTTONACTION(len)			_IOC( _IOC_WRITE, 'j', 0x51, len )

/**
  \brief Sets an action to the given axis

  This funcion will assign a new action, identified by the axis ID and band ranges given, to
  the axis. If another action matching the same axis ID and band is found, it will be overwritten.

  This function should be called by passing it a pointer to a t_JSMAPPER_ACTION structure, appropiately 
  sized to the action type specified.
  
  \warning The driver does not perform any check about axis actions ranges overlapping. If they
		   do, behaviour is unredictable.
  */
#define JMIOCSAXISACTION(len)			_IOC( _IOC_WRITE, 'j', 0x52, len )


/**
  \brief Add new mode

  Adds a new mode to device. On input, the parameter 'parentModeID' field should contain the identifier of 
  the parent mode for the new one, plus a a proper trigger condition. 
  
  On output, the 'modeID' field will contain the identifier assigned to the newly created mode, 
  if succesful.
*/
#define JMIOCADDMODE					_IOWR('j', 0x53, struct t_JSMAPPER_MODE )


/**
  \brief Set profile name

  Sets loaded profile name, for informational purposes. The name of the current
  profile can be retrieved by using JMIOCGPROFILENAME;

  \param len Profile name length, not counting terminating null character
  */
#define JMIOCSPROFILENAME(len)			_IOC(_IOC_WRITE, 'j', 0x44, len)

/**
  \brief Gets profile name

  Retrieves the name of currently loaded profile, if any. The string is returned
  empty if no profile is loaded.

  \param len Size of buffer provided, in bytes
  */
#define JMIOCGPROFILENAME(len)			_IOC(_IOC_READ, 'j', 0x45, len)


#endif
